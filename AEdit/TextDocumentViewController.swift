//
//  TextDocumentViewController.swift
//  AEdit
//
//  Created by Andy Hooper on 2020-11-12.
//  Copyright Â© 2020 Andy Hooper. All rights reserved.
//

import Cocoa

class TextDocumentViewController: NSViewController {
    
    var lineSpacing = CGFloat(1.0)
    
    @IBOutlet var textEditView: TextEditView!
    @IBOutlet weak var selectionRangeTextField: NSTextField!
    @IBOutlet weak var definitionsTableView: NSTableView!
    
    var initialFirstResponder: NSView?

    override var representedObject: Any? {
        didSet {
            // Pass down the represented object to all of the child view controllers.
            //print(className, "representedObject", representedObject ?? "nil", children)
            for child in children {
                child.representedObject = representedObject
            }
            if isViewLoaded {
                didSetRepresentedObject()
            }
        }
    }
    
    weak var document: TextDocument? {
        if let docRepresentedObject = representedObject as? TextDocument {
            return docRepresentedObject
        }
        return nil
    }
    
    private func didSetRepresentedObject() {
        if let textDocument = representedObject as? TextDocument {
            title = textDocument.fileURL?.lastPathComponent ?? "Untitled"
            textEditView.layoutManager?.replaceTextStorage(textDocument.content)
            if let textStorage = textEditView.textStorage {
                textStorage.setAttributes([.paragraphStyle: defaultParagraphStyle],
                                         range:NSRange(location:0, length:textStorage.length))
            }
            //textDocument.syntaxHighlighter?.scheduleScan() //.scanTokens()
            //TODO may not be needed as a textStorage(_:didProcessEditing:range:changeInLength:) is generated by loading the content
            //textDocument.syntaxHighlighter?.scanDefinitions()
            definitionsTableView.dataSource = textDocument.syntaxHighlighter
            definitionsTableView.delegate = self
        }
    }
    
    var defaultParagraphStyle = NSMutableParagraphStyle()
    var fontObserver,
        fontSizeObserver,
        backgroundObserver,
        spacingObserver,
        tabIntervalObserver: DefaultsObserver? // have to assign to retain observers

    fileprivate func tabWidth(_ font: NSFont) -> CGFloat {
        return CGFloat(textEditView.tabInterval) * font.characterAdvance(" ").width
    }
    
    override func viewDidLoad() {
        super.viewDidLoad()
        
        textEditView.delegate = self
        
        let font = defaultsFont()
        textEditView.font = font
        initialFirstResponder = textEditView

        let layoutManager = TextLayoutManager()
        layoutManager.textFont = font
        layoutManager.usesAntialias = true //TODO preference
        textEditView.textContainer?.replaceLayoutManager(layoutManager)
        textEditView.layoutManager?.showsControlCharacters = true // enable override to decide about showing
        
        // ruler has to be set after layout manager is replaced
        let lnv = LineNumberRulerView(textView: textEditView)
        if let textScrollView = textEditView.enclosingScrollView {
            textScrollView.verticalRulerView = lnv
            textScrollView.hasVerticalRuler = true
            textScrollView.rulersVisible = true
        }
        
        // Interface Builder lets these go to user preferences (Keyboard)
        textEditView.isAutomaticSpellingCorrectionEnabled = false
        textEditView.isAutomaticQuoteSubstitutionEnabled = false
        textEditView.isAutomaticDashSubstitutionEnabled = false
        textEditView.isAutomaticLinkDetectionEnabled = true
        textEditView.isAutomaticDataDetectionEnabled = false
        textEditView.isAutomaticTextReplacementEnabled = false
        textEditView.isAutomaticTextCompletionEnabled = false
        
        //TODO where to set incrementalSearchingShouldDimContentView = false
        
        lineSpacing = Defaults[.lineSpacing]
        defaultParagraphStyle.lineSpacing = lineSpacing
        textEditView.tabInterval = Defaults[.tabInterval]
        defaultParagraphStyle.tabStops = []
        defaultParagraphStyle.defaultTabInterval = tabWidth(font)
        textEditView.defaultParagraphStyle = defaultParagraphStyle
        if let textStorage = textEditView.textStorage {
            textStorage.setAttributes([.paragraphStyle: defaultParagraphStyle],
                                     range:NSRange(location:0, length:textStorage.length))
        }
        textEditView.typingAttributes[.paragraphStyle] = defaultParagraphStyle
        
        if let backgroundColour = Defaults[.backgroundColour] {
            textEditView.backgroundColor = backgroundColour
        }
        fontObserver = Defaults.observe(key:.fontName, options:[.new]) { update in
            //print(self.className, "observe fontName", update.newValue ?? "nil")
            self.updateFont()
        }
        fontSizeObserver = Defaults.observe(key:.fontSize, options:[.new]) { update in
            //print(self.className, "observe fontSize", update.newValue ?? "nil")
            self.updateFont()
        }
        backgroundObserver = Defaults.observe(key:.backgroundColour, options:[.new]) { update in
            //print(self.className, "observe backgroundColour", update.newValue ?? "nil")
            if let colour = update.newValue {
                self.textEditView.backgroundColor = colour
            }
        }
        spacingObserver = Defaults.observe(key:.lineSpacing, options:[.new]) { update in
            //print(self.className, "observe lineSpacing", update.newValue ?? "nil")
            if let spacing = update.newValue {
                self.lineSpacing = spacing
                self.defaultParagraphStyle.lineSpacing = self.lineSpacing
                //TODO reapply defaultParagraphStyle
            }
        }
        tabIntervalObserver = Defaults.observe(key:.tabInterval, options:[.new]) { update in
            print(self.className, "observe tabInterval", update.newValue ?? "nil")
            if let tabInterval = update.newValue {
                self.textEditView.tabInterval = tabInterval
                self.defaultParagraphStyle.defaultTabInterval = self.tabWidth(font)
                //TODO reapply defaultParagraphStyle
            }
        }
        NotificationCenter.default.addObserver(self, selector: #selector(syntaxStyleDidChange(_:)), name:SyntaxStyle.styleNnotificationName, object:nil)
        NotificationCenter.default.addObserver(self, selector: #selector(definitionsTableDidChange(_:)), name:SyntaxHighlighter.definitionsNnotificationName, object:nil)

        didSetRepresentedObject()
        updateFont()
        updateLineAndColumn()
    }
    
    @objc func syntaxStyleDidChange(_ notification:Notification) {
        //print(className, #function)
        // crude, but not executed frequently
        textEditView.setNeedsDisplay(textEditView.bounds)
    }
    
    @objc func definitionsTableDidChange(_ notification:Notification) {
        if (notification.object as? SyntaxHighlighter) === document?.syntaxHighlighter {
            //print(className, #function, notification.object)
            definitionsTableView.reloadData()
        }
    }

    deinit {
        NotificationCenter.default.removeObserver(self)
    }

    private func defaultsFont()->NSFont {
        let size = Defaults[.fontSize]
        if let name = Defaults[.fontName],
           let font = NSFont(name:name, size: size) {
            return font
        }
        return NSFont.monospacedSystemFont(ofSize:size, weight:.regular)

    }
    private func updateFont() {
        let font = defaultsFont()
        //print(className, #function, font.fontName, font.pointSize)
        textEditView.font = font
        (textEditView.layoutManager as? TextLayoutManager)?.textFont = font
        defaultParagraphStyle.defaultTabInterval = self.tabWidth(font)
    }

    private func updateLineAndColumn() {
        let selectedRanges = textEditView.selectedRanges
        if selectedRanges.count > 1 {
            selectionRangeTextField.stringValue = formatSelectionRange(selectedRanges.first as! NSRange) +
                        "..." + formatSelectionRange(selectedRanges.last as! NSRange)
        } else if selectedRanges.count == 1 {
            selectionRangeTextField.stringValue = formatSelectionRange(selectedRanges.first as! NSRange)
        } else {
            selectionRangeTextField.stringValue = "no selection"
        }
    }
    
    private func formatSelectionRange(_ range:NSRange)->String {
        if range.length > 0 {
            return formatLineAndColumn(range.lowerBound)+"-"+formatLineAndColumn(range.upperBound)
        }
        return formatLineAndColumn(range.lowerBound)
    }
    
    private func formatLineAndColumn(_ index:Int)->String {
        let (line,column) = LineNumberRulerView.lineAndColumnNumber(at:index, in:textEditView.string)
        if column == 1 {
            return String(line)
        }
        return String(line)+":"+String(column)
    }
    
    var previousSelectedLinesRect: NSRect?

//    override func viewDidAppear() {
//        if let document = representedObject as? NSDocument {
//            print(className, #function, document.fileURL ?? "nil")
//            // TODO check for external file modification
//        }
//        super.viewDidAppear()
//    }
    
//    override func commitEditing(withDelegate delegate: Any?, didCommit didCommitSelector: Selector?, contextInfo: UnsafeMutableRawPointer?) {
//        print(className, #function, didCommitSelector)
//        super.commitEditing(withDelegate: delegate, didCommit: didCommitSelector, contextInfo: contextInfo)
//        print(className, #function)
//    }
}

extension TextDocumentViewController: NSTextViewDelegate {
    
    func textDidBeginEditing(_ notification: Notification) {
        //print(className, #function, document?.fileURL)
        document?.objectDidBeginEditing(self)
    }

    func textDidEndEditing(_ notification: Notification) {
        //print(className, #function)
        document?.objectDidEndEditing(self)
    }
    
    func textViewDidChangeSelection(_ notification: Notification) {
        updateLineAndColumn()
        textEditView.needsDisplay = true // to redraw selection line highlight
        if let previousSelectedLinesRect = previousSelectedLinesRect {
            textEditView.setNeedsDisplay(previousSelectedLinesRect)
            self.previousSelectedLinesRect = nil
        }
        if let selectedLinesRect = textEditView.selectedLinesRect() {
            textEditView.setNeedsDisplay(selectedLinesRect)
            previousSelectedLinesRect = selectedLinesRect
            textEditView.updateRuler()
        }
    }
    
}

extension TextDocumentViewController: NSTableViewDelegate {
    
    func tableView(_ tableView: NSTableView, viewFor tableColumn: NSTableColumn?, row: Int) -> NSView? {
        let item = tableView.dataSource?.tableView?(tableView, objectValueFor: tableColumn, row: row)
        let cellView = tableView.makeView(withIdentifier:tableColumn!.identifier, owner:self) as! NSTableCellView
        cellView.objectValue = item
        if let definition = item  as? SyntaxHighlighter.SymbolDefinition {
            cellView.textField?.stringValue = String(definition.name)
        } else {
            cellView.textField?.stringValue =  item.debugDescription
        }
        return cellView
    }
    
    func tableViewSelectionDidChange(_ notification: Notification) {
        let item = definitionsTableView.dataSource?.tableView?(definitionsTableView,
                                                               objectValueFor: definitionsTableView.tableColumns[0],
                                                               row: definitionsTableView.selectedRow)
        if let definition = item  as? SyntaxHighlighter.SymbolDefinition {
            textEditView.setSelectedRange(NSRange(location:definition.position.location, length:0))
            textEditView.scrollRangeToVisible(definition.position)
            textEditView.window?.makeFirstResponder(textEditView)
        }
    }
    
}

extension NSFont {
    
    func characterAdvance(_ character:Character)->CGSize {
        // CotEditor-3.8.9/CotEditor/Sources/NSFont+Size.swift
        precondition(character.utf16.count == 1)
        let unicodeChar = character.utf16.first!
        var glyph = CGGlyph()
        CTFontGetGlyphsForCharacters(self, [unicodeChar], &glyph, 1)
        var advance: CGSize = .zero
        CTFontGetAdvancesForGlyphs(self, .horizontal, &glyph, &advance, 1)
        return advance
    }
    
}

